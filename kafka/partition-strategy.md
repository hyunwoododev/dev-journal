# Kafka 구성 및 베스트 프랙티스

이 문서는 Kafka의 파티션 설정, 재시도 정책, 오류 처리, Dead Letter Queue (DLQ) 처리, 클라이언트 구성 권장 사항에 대한 가이드를 제공합니다.

## 1. 파티션 수 설정

Kafka의 성능을 최적화하기 위해 적절한 파티션 수를 결정하는 것이 중요합니다.

### 파티션 수 계산 공식

```
# 파티션 수 = max(Np, Nc)
```
- **Np**: 필요한 프로듀서 수 (`Tt / Tp`로 계산)
- **Nc**: 필요한 컨슈머 수 (`Tt / Tc`로 계산)
- **Tt**: 시스템의 총 예상 처리량
- **Tp**: 단일 프로듀서가 단일 파티션에 대해 달성할 수 있는 최대 처리량
- **Tc**: 단일 컨슈머가 단일 파티션에서 소비할 수 있는 최대 처리량

### 주요 고려사항

- **파일 디스크립터**: 파티션 수가 많아질수록 파일 디스크립터 사용량이 증가하므로 시스템 설정을 조정해야 합니다.
- **여유 설정**: 필요 이상으로 파티션을 적게 설정하지 않고 여유 있게 설정하는 것이 좋습니다.
- **파티션 수 감소 불가**: 파티션 수를 줄이는 것은 지원되지 않으며, 새 토픽을 생성하여 데이터를 복사하는 방식을 사용해야 합니다.
- **권장 한도**: 브로커당 4000개 이하의 파티션, 클러스터당 20만 개 이하의 파티션이 적절합니다.

## 2. 파티션 할당 및 리밸런스 전략

Kafka는 파티션을 컨슈머에게 할당하는 다양한 전략을 사용하며, 리밸런스는 컨슈머가 그룹을 떠나거나 새로 들어올 때, 파티션이 추가될 때 발생합니다.

### 리밸런스 모드

- **Eager Rebalance**: 모든 컨슈머가 일시 중지하고 파티션을 재할당합니다. (기본 모드)
- **Cooperative Rebalance**: 필요한 파티션만 이동하여 나머지 컨슈머는 계속 데이터를 처리할 수 있습니다.

### 파티션 할당 전략

- **RangeAssignor**: 토픽별로 파티션을 할당하며 불균형이 발생할 수 있음.
- **RoundRobinAssignor**: 라운드 로빈 방식으로 할당하여 균형을 맞춤.
- **StickyAssignor**: RoundRobinAssignor와 유사하나, 파티션 이동을 최소화.
- **CooperativeStickyAssignor**: StickyAssignor와 유사하지만 Cooperative Rebalance를 지원하여 일부 컨슈머가 계속 처리 가능.

## 3. 메시지 배칭

프로듀서 측에서 메시지 배칭을 설정하여 전송 효율을 높일 수 있습니다.

- **batch.size**: 배치 크기의 상한값을 바이트 단위로 설정 (기본값: 16384 바이트)
- **linger.ms**: 배치 크기 제한에 도달하기 전 기다리는 시간 (기본값: 0 ms)

### 설정 팁

- 큰 `batch.size`는 요청 수를 줄여 전송 효율을 높입니다.
- 데이터 전송량이 적을 경우 `linger.ms` 값을 적절히 조정하여 지연을 방지할 수 있습니다.

## 4. 재시도 정책 및 오류 처리

재시도 정책 및 오류 처리를 통해 Kafka 메시지의 신뢰성을 확보할 수 있습니다.

### 프로듀서 측 재시도 설정

- **acks**: `all`로 설정하여 모든 복제본이 메시지를 확인할 때까지 대기.
- **message.send.max.retries**: 전송 실패 시 재시도 횟수 설정.
- **retry.backoff.ms**: 재시도 간 대기 시간.

### 오류 유형

- **일시적 오류**: LEADER_NOT_AVAILABLE 등 자동으로 재시도 가능한 오류.
- **영구적 오류**: INVALID_CONFIG 등 수동 처리가 필요한 오류.

### Polly 라이브러리 사용

Polly를 사용하여 `Produce` 및 `Consume` 메서드 호출 시 오류가 발생하면, Polly 설정에 따라 재시도하고, 메시지 전송을 추적합니다.

## 5. Dead Letter Queue (DLQ) 처리

Kafka는 기본적으로 DLQ를 지원하지 않으므로, 별도의 큐를 생성하여 처리가 불가능한 메시지를 처리해야 합니다.

### DLQ 처리 옵션

- **재처리**: 오류 수정 후 메시지를 재처리.
- **폐기**: 분석 후 문제가 있는 메시지를 폐기.
- **고급 분석**: ksqlDB 등을 사용하여 DLQ 데이터 분석.
- **워크플로우 중단**: 오류가 발생하면 전체 워크플로우를 중단하고 문제를 해결한 후 재시작.
- **무시**: DLQ를 모니터링하며 특정 오류를 무시.

### DLQ 베스트 프랙티스

- DLQ 메시지 처리 방식에 대한 자동화 및 수동 프로세스를 정의합니다.
- 인프라 팀이 아닌 데이터 소유자가 알림을 받도록 설정합니다.
- 재처리 및 문제 해결을 위해 원본 메시지와 오류 정보를 포함시킵니다.
- DLQ를 논리적으로 그룹화하여 문제 해결과 재처리를 용이하게 합니다.

## 6. Kafka 클라이언트 권장 구성

### 프로듀서 구성

- **batch.size**: 1000000으로 설정 권장.
- **message.send.max.retries**: 0
- **retry.backoff.ms**: 1000
- **request.timeout.ms**: 60000
- **metadata.max.idle.ms**: 180000
- **linger.ms**: 고성능 시나리오에 맞게 조정.
- **compression.type**: Snappy 권장.

### 컨슈머 구성

- **max.poll.interval.ms**: 300000
- **session.timeout.ms**: 30000
- **heartbeat.interval.ms**: 3000 (기본값 유지 권장)

---


# Kafka 파티션 수 설정 가이드 (IoT Core -> Lambda -> Kafka)

Kafka에서 적절한 파티션 수를 설정하려면, IoT Core에서 Lambda를 거쳐 Kafka로 전달될 **하루 메시지량**을 기준으로 파티션 수와 컨슈머 수를 고려해야 합니다. 아래는 하루 메시지의 최대값과 평균값을 바탕으로 처리량 요구를 계산하는 방법입니다.

## 1. 초당 메시지 전송량 계산

먼저 하루의 최대 메시지량과 평균 메시지량을 바탕으로 **초당 전송량**을 계산합니다.

- **최대 메시지 전송량** (하루 9.79M 메시지 기준):
  - 9,790,000 메시지 / 86,400초 ≈ 약 **113 메시지/초**
- **평균 메시지 전송량** (하루 평균 7.32M 메시지 기준):
  - 7,320,000 메시지 / 86,400초 ≈ 약 **85 메시지/초**

이 정보를 바탕으로 Kafka의 파티션 수를 계산할 수 있습니다.

## 2. 파티션 수 계산

공식을 사용하여 필요한 파티션 수를 계산합니다:

```
파티션 수 = max(Tt / Tp, Tt / Tc)
```

여기서:
- **Tt**는 총 처리량 (113 메시지/초 기준)
- **Tp**와 **Tc**는 프로듀서와 컨슈머 각각의 단일 파티션 처리량입니다.

일반적으로 Kafka에서 각 파티션이 **1000 메시지/초**를 안정적으로 처리할 수 있다고 가정합니다.

- **Np** (프로듀서에 필요한 파티션 수):
  \[
  Np = Tt / Tp ≈ 113 / 1000 ≈ 1
  \]
- **Nc** (컨슈머에 필요한 파티션 수):
  \[
  Nc = Tt / Tc ≈ 113 / 1000 ≈ 1
  \]

## 3. 파티션 수 최적화

IoT 메시지의 변동성을 고려하여 여유 있게 **4개의 파티션**을 설정하는 것이 좋습니다. 이렇게 설정하면 병렬 처리 성능을 최적화하고, 향후 처리량이 증가할 경우에도 안정적으로 대응할 수 있습니다.

## 4. 설정 요약

- **파티션 수**: 4
- **컨슈머 수**: 4 (파티션 당 1개의 컨슈머가 병렬로 처리하도록 설정)

이렇게 하면 평균과 최대 메시지량을 안정적으로 처리할 수 있으며, 컨슈머 측에서도 균형 있게 부하를 분산하여 성능을 최적화할 수 있습니다.

---

이 가이드는 IoT 메시지 처리 요구에 맞춘 Kafka 파티션 수 설정의 예를 제공합니다.
